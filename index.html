<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mission 009 보드게임</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --panel-2: #1f2937;
      --text: #e2e8f0;
      --accent: #38bdf8;
      --board: #334155;
      --cell: #1e293b;
      --cell-border: #475569;
      --truce: #14532d;
      --selected: #f59e0b;
      --move: #22c55e;
      --black: #0f172a;
      --white: #f8fafc;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Pretendard", "Noto Sans KR", sans-serif;
      background: radial-gradient(circle at top, #1e293b, #0b1120 60%);
      color: var(--text);
    }

    main {
      max-width: 1200px;
      margin: 0 auto;
      padding: 32px 20px 48px;
      display: grid;
      grid-template-columns: minmax(320px, 520px) 1fr;
      gap: 24px;
    }

    h1 {
      margin: 0 0 12px;
      font-size: 28px;
    }

    .panel {
      background: var(--panel);
      border: 1px solid #1f2937;
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.45);
    }

    .board-wrap {
      display: grid;
      gap: 12px;
    }

    .board {
      display: grid;
      grid-template-columns: 40px repeat(9, 1fr);
      grid-template-rows: 40px repeat(9, 1fr);
      border-radius: 16px;
      overflow: hidden;
      border: 2px solid #334155;
      background: var(--board);
    }

    .cell,
    .label {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      border: 1px solid var(--cell-border);
    }

    .cell {
      background: var(--cell);
      position: relative;
      min-height: 52px;
    }

    .label {
      background: #0b1120;
      font-weight: 700;
      color: #94a3b8;
    }

    .cell.truce {
      background: var(--truce);
    }

    .cell.selected {
      outline: 3px solid var(--selected);
      z-index: 2;
    }

    .cell.available::after {
      content: "";
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--move);
      position: absolute;
      bottom: 6px;
      right: 6px;
      box-shadow: 0 0 12px rgba(34, 197, 94, 0.7);
    }

    .piece {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 14px;
      border: 2px solid transparent;
      box-shadow: 0 0 12px rgba(15, 23, 42, 0.4);
    }

    .piece.black {
      background: #0f172a;
      color: #f8fafc;
      border-color: #94a3b8;
    }

    .piece.white {
      background: #f8fafc;
      color: #0f172a;
      border-color: #cbd5f5;
    }

    .mission {
      font-size: 13px;
      font-weight: 700;
      background: #0f172a;
      padding: 4px 6px;
      border-radius: 6px;
      color: #facc15;
    }

    .legend {
      display: grid;
      gap: 8px;
      font-size: 14px;
      line-height: 1.5;
    }

    .status {
      display: grid;
      gap: 8px;
      margin-top: 12px;
    }

    .turn {
      font-size: 16px;
      font-weight: 700;
      color: var(--accent);
    }

    .log {
      max-height: 220px;
      overflow-y: auto;
      background: #0b1120;
      border-radius: 12px;
      padding: 12px;
      font-size: 13px;
      line-height: 1.5;
    }

    .controls {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 12px;
    }

    button {
      border: none;
      background: var(--accent);
      color: #0b1120;
      font-weight: 700;
      padding: 10px 16px;
      border-radius: 10px;
      cursor: pointer;
    }

    button.secondary {
      background: #334155;
      color: #e2e8f0;
    }

    @media (max-width: 960px) {
      main {
        grid-template-columns: 1fr;
      }

      .board {
        width: min(100%, 520px);
        aspect-ratio: 1 / 1;
        grid-template-columns: 32px repeat(9, 1fr);
        grid-template-rows: 32px repeat(9, 1fr);
        justify-self: center;
      }

      .cell,
      .label {
        min-height: 0;
        aspect-ratio: 1 / 1;
      }
    }
  </style>
</head>
<body>
  <main>
    <section class="panel board-wrap">
      <h1>Mission 009 전략 보드게임</h1>
      <div id="board" class="board" aria-label="9x9 보드"></div>
      <div class="status">
        <div id="turn" class="turn"></div>
        <div id="message"></div>
        <div class="controls">
          <button id="reset">새 게임</button>
          <button id="toggleHints" class="secondary">이동 표시 끄기</button>
        </div>
      </div>
    </section>
    <aside class="panel">
      <h2>게임 규칙 요약</h2>
      <div class="legend">
        <div>• 검은색이 선공이며, 인접한 상하좌우·대각선 1칸 이동.</div>
        <div>• 2칸 이동 가능(1·9열/중립지역 도착 불가, 중립지역 출발 불가, 말 통과·포획 불가).</div>
        <div>• 검은색은 1열로 이동 불가, 흰색은 9열로 이동 불가.</div>
        <div>• 휴전지역(C5~G5)에 상대가 있으면 이동 불가.</div>
        <div>• 전투는 숫자 비교: 큰 숫자 승, 단 차이가 1이면 작은 숫자 승.</div>
        <div>• 1 vs 9은 1 승리, 2·3 vs 8은 작은 쪽 승리.</div>
        <div>• 같은 숫자는 이동한 쪽 승리.</div>
        <div>• 자신의 숫자와 일치하는 상대편 임무번호 칸 3곳 이상 도달 시 승리.</div>
      </div>
      <h3>전투 로그</h3>
      <div id="log" class="log"></div>
    </aside>
  </main>

  <script>
    const boardEl = document.getElementById("board");
    const turnEl = document.getElementById("turn");
    const messageEl = document.getElementById("message");
    const logEl = document.getElementById("log");
    const resetBtn = document.getElementById("reset");
    const toggleHintsBtn = document.getElementById("toggleHints");

    const ROWS = "ABCDEFGHI".split("");
    const COLS = [1, 2, 3, 4, 5, 6, 7, 8, 9];
    const STARTING_ORDER = [1, 3, 5, 7, 9, 8, 6, 4, 2];
    const TRUCE_ROWS = ["C", "D", "E", "F", "G"];
    const TRUCE_COL = 5;

    let state;
    let showHints = true;

    const createEmptyState = () => ({
      pieces: [],
      missions: { col1: {}, col9: {} },
      missionProgress: { black: [], white: [] },
      selected: null,
      currentPlayer: "black",
      gameOver: false,
    });

    const log = (text) => {
      const entry = document.createElement("div");
      entry.textContent = text;
      logEl.prepend(entry);
    };

    const coordKey = (row, col) => `${row}${col}`;

    const isTruce = (row, col) => TRUCE_COL === col && TRUCE_ROWS.includes(row);

    const shuffle = (array) => {
      for (let i = array.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    };

    const generateMissionsForColumn = () => {
      const missions = {};
      const groups = [shuffle([1, 2, 3]), shuffle([4, 5, 6]), shuffle([7, 8, 9])];
      for (let block = 0; block < 3; block += 1) {
        const blockRows = ROWS.slice(block * 3, block * 3 + 3);
        const blockNumbers = shuffle([groups[0][block], groups[1][block], groups[2][block]]);
        blockRows.forEach((row, idx) => {
          missions[row] = blockNumbers[idx];
        });
      }
      return missions;
    };

    const setupGame = () => {
      state = createEmptyState();
      state.missions.col1 = generateMissionsForColumn();
      state.missions.col9 = generateMissionsForColumn();
      state.pieces = [];
      ROWS.forEach((row, idx) => {
        const pieceNumber = STARTING_ORDER[idx];
        state.pieces.push({
          id: `B${pieceNumber}`,
          color: "black",
          number: pieceNumber,
          row,
          col: 2,
          alive: true,
        });
        state.pieces.push({
          id: `W${pieceNumber}`,
          color: "white",
          number: pieceNumber,
          row,
          col: 8,
          alive: true,
        });
      });
      state.selected = null;
      state.currentPlayer = "black";
      state.gameOver = false;
      logEl.innerHTML = "";
      messageEl.textContent = "";
      render();
      turnEl.textContent = "현재 턴: 검은색(플레이어)";
      log("새 게임 시작! 검은색이 먼저 움직입니다.");
    };

    const getPieceAt = (row, col, customState = state) =>
      customState.pieces.find((piece) => piece.alive && piece.row === row && piece.col === col);

    const inBounds = (rowIndex, colIndex) =>
      rowIndex >= 0 && rowIndex < 9 && colIndex >= 0 && colIndex < 9;

    const getLegalMoves = (piece, customState = state) => {
      if (!piece || !piece.alive) return [];
      const moves = [];
      const rowIndex = ROWS.indexOf(piece.row);
      const colIndex = COLS.indexOf(piece.col);
      const canTwoStep = !isTruce(piece.row, piece.col);
      for (let dr = -1; dr <= 1; dr += 1) {
        for (let dc = -1; dc <= 1; dc += 1) {
          if (dr === 0 && dc === 0) continue;
          const nr = rowIndex + dr;
          const nc = colIndex + dc;
          if (!inBounds(nr, nc)) continue;
          const targetRow = ROWS[nr];
          const targetCol = COLS[nc];
          if (piece.color === "black" && targetCol === 1) continue;
          if (piece.color === "white" && targetCol === 9) continue;
          const occupant = getPieceAt(targetRow, targetCol, customState);
          if (occupant && occupant.color === piece.color) continue;
          if (isTruce(targetRow, targetCol) && occupant && occupant.color !== piece.color) continue;
          moves.push({ row: targetRow, col: targetCol });
          if (!canTwoStep) continue;
          const nr2 = rowIndex + dr * 2;
          const nc2 = colIndex + dc * 2;
          if (!inBounds(nr2, nc2)) continue;
          const targetRow2 = ROWS[nr2];
          const targetCol2 = COLS[nc2];
          if (targetCol2 === 1 || targetCol2 === 9) continue;
          if (isTruce(targetRow2, targetCol2)) continue;
          const midRow = ROWS[rowIndex + dr];
          const midCol = COLS[colIndex + dc];
          if (getPieceAt(midRow, midCol, customState)) continue;
          if (getPieceAt(targetRow2, targetCol2, customState)) continue;
          moves.push({ row: targetRow2, col: targetCol2 });
        }
      }
      return moves;
    };

    const compareBattle = (attacker, defender) => {
      if (attacker.number === defender.number) return "attacker";
      const diff = Math.abs(attacker.number - defender.number);
      if (diff === 1) return attacker.number < defender.number ? "attacker" : "defender";
      if (
        (attacker.number === 1 && defender.number === 9) ||
        (attacker.number === 9 && defender.number === 1)
      ) {
        return attacker.number === 1 ? "attacker" : "defender";
      }
      if (
        (attacker.number === 8 && [2, 3].includes(defender.number)) ||
        (defender.number === 8 && [2, 3].includes(attacker.number))
      ) {
        return [2, 3].includes(attacker.number) ? "attacker" : "defender";
      }
      return attacker.number > defender.number ? "attacker" : "defender";
    };

    const checkWin = (piece, customState = state) => {
      if (!piece || !piece.alive) return false;
      if (piece.color === "black" && piece.col === 9) {
        if (customState.missions.col9[piece.row] !== piece.number) return false;
        if (!customState.missionProgress.black.includes(piece.row)) {
          customState.missionProgress.black.push(piece.row);
        }
        return customState.missionProgress.black.length >= 3;
      }
      if (piece.color === "white" && piece.col === 1) {
        if (customState.missions.col1[piece.row] !== piece.number) return false;
        if (!customState.missionProgress.white.includes(piece.row)) {
          customState.missionProgress.white.push(piece.row);
        }
        return customState.missionProgress.white.length >= 3;
      }
      return false;
    };

    const endGame = (winnerColor, reason) => {
      state.gameOver = true;
      const winnerName = winnerColor === "black" ? "검은색" : "흰색";
      messageEl.textContent = `${winnerName} 승리! ${reason}`;
      log(`${winnerName} 승리! ${reason}`);
      turnEl.textContent = "게임 종료";
    };

    const movePiece = (piece, destination) => {
      if (state.gameOver) return;
      const target = getPieceAt(destination.row, destination.col);
      let battleResult = null;
      if (target && !isTruce(destination.row, destination.col)) {
        battleResult = compareBattle(piece, target);
        if (battleResult === "attacker") {
          target.alive = false;
          log(`${piece.color === "black" ? "검" : "백"}${piece.number}가 ${target.color === "black" ? "검" : "백"}${target.number}를 격파!`);
        } else {
          piece.alive = false;
          log(`${piece.color === "black" ? "검" : "백"}${piece.number}가 ${target.color === "black" ? "검" : "백"}${target.number}에게 패배.`);
          return;
        }
      }
      piece.row = destination.row;
      piece.col = destination.col;
      if (checkWin(piece)) {
        endGame(piece.color, "임무번호 칸 3곳을 점령했습니다!");
      }
    };

    const cloneState = (baseState) => JSON.parse(JSON.stringify(baseState));

    const applyMoveToState = (baseState, pieceId, destination) => {
      const nextState = cloneState(baseState);
      const piece = nextState.pieces.find((p) => p.id === pieceId);
      if (!piece || !piece.alive) return { state: nextState, winner: null };
      const target = getPieceAt(destination.row, destination.col, nextState);
      if (target && !isTruce(destination.row, destination.col)) {
        const battleResult = compareBattle(piece, target);
        if (battleResult === "attacker") {
          target.alive = false;
        } else {
          piece.alive = false;
          return { state: nextState, winner: null };
        }
      }
      piece.row = destination.row;
      piece.col = destination.col;
      if (checkWin(piece, nextState)) {
        nextState.gameOver = true;
        nextState.winner = piece.color;
        return { state: nextState, winner: piece.color };
      }
      return { state: nextState, winner: null };
    };

    const getAllMoves = (customState, color) => {
      const moves = [];
      customState.pieces
        .filter((piece) => piece.alive && piece.color === color)
        .forEach((piece) => {
          getLegalMoves(piece, customState).forEach((move) => {
            moves.push({ pieceId: piece.id, move });
          });
        });
      return moves;
    };

    const serializeState = (customState, currentPlayer) => {
      const pieceInfo = customState.pieces
        .map((piece) => `${piece.id}:${piece.alive ? 1 : 0}:${piece.row}${piece.col}`)
        .sort()
        .join("|");
      const progress = `B${[...customState.missionProgress.black].sort().join("")}-W${[
        ...customState.missionProgress.white,
      ].sort().join("")}`;
      return `${currentPlayer}|${pieceInfo}|${progress}`;
    };

    const evaluateTerminal = (customState, currentPlayer) => {
      if (customState.gameOver && customState.winner) {
        return { score: customState.winner === "white" ? 10000 : -10000, depth: 0 };
      }
      const moves = getAllMoves(customState, currentPlayer);
      if (moves.length === 0) {
        return { score: currentPlayer === "white" ? -10000 : 10000, depth: 0 };
      }
      return null;
    };

    const chooseBetterResult = (currentPlayer, best, candidate) => {
      if (currentPlayer === "white") {
        if (candidate.score > best.score) return candidate;
        if (candidate.score < best.score) return best;
        if (candidate.score === 1 && candidate.depth < best.depth) return candidate;
        if (candidate.score === -1 && candidate.depth > best.depth) return candidate;
        if (candidate.score === 0 && candidate.depth < best.depth) return candidate;
        return best;
      }
      if (candidate.score < best.score) return candidate;
      if (candidate.score > best.score) return best;
      if (candidate.score === -1 && candidate.depth < best.depth) return candidate;
      if (candidate.score === 1 && candidate.depth > best.depth) return candidate;
      if (candidate.score === 0 && candidate.depth < best.depth) return candidate;
      return best;
    };

    const buildTargetRowMap = (missions) => {
      const map = {};
      ROWS.forEach((row) => {
        map[missions[row]] = row;
      });
      return map;
    };

    const evaluatePosition = (customState) => {
      if (customState.gameOver && customState.winner) {
        return customState.winner === "white" ? 10000 : -10000;
      }
      const targetRowWhite = buildTargetRowMap(customState.missions.col1);
      const targetRowBlack = buildTargetRowMap(customState.missions.col9);
      let score = 0;
      const whiteMoves = getAllMoves(customState, "white").length;
      const blackMoves = getAllMoves(customState, "black").length;
      score += (whiteMoves - blackMoves) * 2;
      score += (customState.missionProgress.white.length - customState.missionProgress.black.length) * 250;
      customState.pieces.forEach((piece) => {
        if (!piece.alive) return;
        const rowIndex = ROWS.indexOf(piece.row);
        if (piece.color === "white") {
          score += 25;
          score += piece.number * 1.5;
          const targetRow = targetRowWhite[piece.number];
          const dist =
            Math.abs(rowIndex - ROWS.indexOf(targetRow)) + Math.abs(piece.col - 1);
          score += Math.max(0, 28 - dist * 4);
          if (piece.col === 1 && customState.missions.col1[piece.row] === piece.number) {
            score += 400;
          }
        } else {
          score -= 25;
          score -= piece.number * 1.5;
          const targetRow = targetRowBlack[piece.number];
          const dist =
            Math.abs(rowIndex - ROWS.indexOf(targetRow)) + Math.abs(piece.col - 9);
          score -= Math.max(0, 28 - dist * 4);
          if (piece.col === 9 && customState.missions.col9[piece.row] === piece.number) {
            score -= 400;
          }
        }
      });
      return score;
    };

    const isCaptureMove = (customState, move, currentPlayer) => {
      const target = getPieceAt(move.move.row, move.move.col, customState);
      return target && target.color !== currentPlayer && !isTruce(move.move.row, move.move.col);
    };

    const moveKey = (move) => `${move.pieceId}-${move.move.row}${move.move.col}`;

    const scoreMoveOrdering = (customState, move, currentPlayer, history, killers, depth) => {
      const piece = customState.pieces.find((p) => p.id === move.pieceId);
      if (!piece) return 0;
      const target = getPieceAt(move.move.row, move.move.col, customState);
      let score = 0;
      if (target && target.color !== currentPlayer && !isTruce(move.move.row, move.move.col)) {
        score += 1000 + target.number * 5;
      }
      const key = moveKey(move);
      if (killers[depth] && killers[depth].includes(key)) {
        score += 800;
      }
      if (history[key]) {
        score += history[key];
      }
      if (currentPlayer === "white") {
        if (move.move.col === 1 && customState.missions.col1[move.move.row] === piece.number) {
          score += 900;
        }
        score += (piece.col - move.move.col) * 10;
      } else {
        if (move.move.col === 9 && customState.missions.col9[move.move.row] === piece.number) {
          score += 900;
        }
        score += (move.move.col - piece.col) * 10;
      }
      return score;
    };

    const quiescence = (
      customState,
      currentPlayer,
      alpha,
      beta,
      depth,
      memo,
      path,
      deadline,
      history,
      killers
    ) => {
      if (performance.now() > deadline) {
        return { score: evaluatePosition(customState), depth: 0 };
      }
      const standPat = evaluatePosition(customState);
      if (currentPlayer === "white") {
        if (standPat >= beta) return { score: beta, depth: 0 };
        if (alpha < standPat) alpha = standPat;
      } else {
        if (standPat <= alpha) return { score: alpha, depth: 0 };
        if (beta > standPat) beta = standPat;
      }
      if (depth === 0) return { score: standPat, depth: 0 };
      const captureMoves = getAllMoves(customState, currentPlayer).filter((move) =>
        isCaptureMove(customState, move, currentPlayer)
      );
      if (!captureMoves.length) return { score: standPat, depth: 0 };
      const orderedCaptures = captureMoves.sort((a, b) =>
        scoreMoveOrdering(customState, b, currentPlayer, history, killers, depth) -
        scoreMoveOrdering(customState, a, currentPlayer, history, killers, depth)
      );
      const nextPlayer = currentPlayer === "white" ? "black" : "white";
      let best =
        currentPlayer === "white"
          ? { score: -Infinity, depth: Infinity }
          : { score: Infinity, depth: Infinity };
      for (let i = 0; i < orderedCaptures.length; i += 1) {
        if (performance.now() > deadline) break;
        const move = orderedCaptures[i];
        const { state: nextState } = applyMoveToState(customState, move.pieceId, move.move);
        const result = quiescence(
          nextState,
          nextPlayer,
          alpha,
          beta,
          depth - 1,
          memo,
          path,
          deadline,
          history,
          killers
        );
        const candidate = { score: result.score, depth: result.depth + 1 };
        best = chooseBetterResult(currentPlayer, best, candidate);
        if (currentPlayer === "white") {
          alpha = Math.max(alpha, candidate.score);
        } else {
          beta = Math.min(beta, candidate.score);
        }
        if (beta <= alpha) break;
      }
      return best;
    };

    const minimax = (
      customState,
      currentPlayer,
      depth,
      alpha,
      beta,
      memo,
      path,
      deadline,
      history,
      killers
    ) => {
      if (performance.now() > deadline) {
        return { score: evaluatePosition(customState), depth: 0 };
      }
      const key = `${serializeState(customState, currentPlayer)}|${depth}`;
      if (memo.has(key)) {
        const cached = memo.get(key);
        if (cached.depth >= depth) return cached;
      }
      if (path.has(key)) return { score: 0, depth: 0 };
      const terminal = evaluateTerminal(customState, currentPlayer);
      if (terminal) {
        memo.set(key, terminal);
        return terminal;
      }
      if (depth === 0) {
        return quiescence(
          customState,
          currentPlayer,
          alpha,
          beta,
          2,
          memo,
          path,
          deadline,
          history,
          killers
        );
      }
      path.add(key);
      const moves = getAllMoves(customState, currentPlayer).sort((a, b) =>
        scoreMoveOrdering(customState, b, currentPlayer, history, killers, depth) -
        scoreMoveOrdering(customState, a, currentPlayer, history, killers, depth)
      );
      let best =
        currentPlayer === "white"
          ? { score: -Infinity, depth: Infinity }
          : { score: Infinity, depth: Infinity };
      const nextPlayer = currentPlayer === "white" ? "black" : "white";
      for (let i = 0; i < moves.length; i += 1) {
        const move = moves[i];
        const { state: nextState } = applyMoveToState(customState, move.pieceId, move.move);
        const result = minimax(
          nextState,
          nextPlayer,
          depth - 1,
          alpha,
          beta,
          memo,
          path,
          deadline,
          history,
          killers
        );
        const candidate = { score: result.score, depth: result.depth + 1 };
        best = chooseBetterResult(currentPlayer, best, candidate);
        if (currentPlayer === "white") {
          alpha = Math.max(alpha, candidate.score);
        } else {
          beta = Math.min(beta, candidate.score);
        }
        if (beta <= alpha) {
          const keyMove = moveKey(move);
          history[keyMove] = (history[keyMove] || 0) + depth * depth;
          if (!killers[depth]) killers[depth] = [];
          if (!killers[depth].includes(keyMove)) {
            killers[depth] = [keyMove, killers[depth][0]].filter(Boolean).slice(0, 2);
          }
          break;
        }
        if (performance.now() > deadline) break;
      }
      path.delete(key);
      memo.set(key, best);
      return best;
    };

    const aiTurn = () => {
      if (state.gameOver) return;
      const moves = getAllMoves(state, "white");
      if (moves.length === 0) {
        endGame("black", "흰색이 더 이상 움직일 수 없습니다.");
        return;
      }
      const memo = new Map();
      const path = new Set();
      const startTime = performance.now();
      const deadline = startTime + 9500;
      let bestResult = { score: -Infinity, depth: Infinity };
      let bestMove = moves[0];
      const history = {};
      const killers = [];
      const maxDepth = 5;
      for (let depth = 1; depth <= maxDepth; depth += 1) {
        if (performance.now() > deadline) break;
        let depthBest = { score: -Infinity, depth: Infinity };
        let depthMove = bestMove;
        const orderedMoves = moves
          .slice()
          .sort(
            (a, b) =>
              scoreMoveOrdering(state, b, "white", history, killers, depth) -
              scoreMoveOrdering(state, a, "white", history, killers, depth)
          );
        for (let i = 0; i < orderedMoves.length; i += 1) {
          if (performance.now() > deadline) break;
          const move = orderedMoves[i];
          const { state: nextState } = applyMoveToState(state, move.pieceId, move.move);
          const result = minimax(
            nextState,
            "black",
            depth - 1,
            -Infinity,
            Infinity,
            memo,
            path,
            deadline,
            history,
            killers
          );
          const candidate = { score: result.score, depth: result.depth + 1 };
          if (candidate.score > depthBest.score) {
            depthBest = candidate;
            depthMove = move;
          } else if (candidate.score === depthBest.score && candidate.depth < depthBest.depth) {
            depthBest = candidate;
            depthMove = move;
          }
        }
        if (performance.now() > deadline) break;
        bestResult = depthBest;
        bestMove = depthMove;
      }
      const chosenMove = bestMove;
      const chosenPiece = state.pieces.find((piece) => piece.id === chosenMove.pieceId);
      if (!chosenPiece) {
        endGame("black", "흰색이 움직일 말을 찾지 못했습니다.");
        return;
      }
      movePiece(chosenPiece, chosenMove.move);
      if (!state.gameOver && chosenPiece.alive) {
        log(`흰색 ${chosenPiece.number}번 말 이동: ${chosenMove.move.row}${chosenMove.move.col}`);
      }
      state.currentPlayer = "black";
      state.selected = null;
      render();
      if (!state.gameOver) {
        turnEl.textContent = "현재 턴: 검은색(플레이어)";
      }
    };

    const handleCellClick = (row, col) => {
      if (state.gameOver) return;
      if (state.currentPlayer !== "black") return;
      const piece = getPieceAt(row, col);
      if (piece && piece.color === "black") {
        state.selected = piece;
        messageEl.textContent = `${piece.number}번 말을 선택했습니다.`;
        render();
        return;
      }
      if (!state.selected) return;
      const legal = getLegalMoves(state.selected);
      const isLegal = legal.some((m) => m.row === row && m.col === col);
      if (!isLegal) {
        messageEl.textContent = "이동할 수 없는 칸입니다.";
        return;
      }
      movePiece(state.selected, { row, col });
      if (!state.selected.alive) {
        state.selected = null;
      }
      if (!state.gameOver) {
        state.currentPlayer = "white";
        render();
        turnEl.textContent = "현재 턴: 흰색(AI)";
        setTimeout(aiTurn, 500);
      }
    };

    const buildBoard = () => {
      boardEl.innerHTML = "";
      const labelsTop = ["", ...COLS.map((c) => `${c}`)];
      labelsTop.forEach((label) => {
        const div = document.createElement("div");
        div.className = "label";
        div.textContent = label;
        boardEl.appendChild(div);
      });

      ROWS.forEach((row) => {
        const rowLabel = document.createElement("div");
        rowLabel.className = "label";
        rowLabel.textContent = row;
        boardEl.appendChild(rowLabel);
        COLS.forEach((col) => {
          const cell = document.createElement("div");
          cell.className = "cell";
          if (isTruce(row, col)) {
            cell.classList.add("truce");
          }
          cell.dataset.row = row;
          cell.dataset.col = col;
          cell.addEventListener("click", () => handleCellClick(row, col));
          boardEl.appendChild(cell);
        });
      });
    };

    const render = () => {
      if (!boardEl.children.length) buildBoard();
      const cells = boardEl.querySelectorAll(".cell");
      cells.forEach((cell) => {
        cell.innerHTML = "";
        cell.classList.remove("selected", "available");
      });

      cells.forEach((cell) => {
        const row = cell.dataset.row;
        const col = Number(cell.dataset.col);
        if (col === 1) {
          const mission = document.createElement("div");
          mission.className = "mission";
          mission.textContent = state.missions.col1[row];
          cell.appendChild(mission);
        }
        if (col === 9) {
          const mission = document.createElement("div");
          mission.className = "mission";
          mission.textContent = state.missions.col9[row];
          cell.appendChild(mission);
        }
      });

      state.pieces
        .filter((piece) => piece.alive)
        .forEach((piece) => {
          const cell = Array.from(cells).find(
            (c) => c.dataset.row === piece.row && Number(c.dataset.col) === piece.col
          );
          if (!cell) return;
          const pieceEl = document.createElement("div");
          pieceEl.className = `piece ${piece.color}`;
          pieceEl.textContent = piece.number;
          cell.appendChild(pieceEl);
        });

      if (state.selected) {
        const selectedCell = Array.from(cells).find(
          (c) => c.dataset.row === state.selected.row && Number(c.dataset.col) === state.selected.col
        );
        if (selectedCell) selectedCell.classList.add("selected");
        if (showHints) {
          const moves = getLegalMoves(state.selected);
          moves.forEach((move) => {
            const moveCell = Array.from(cells).find(
              (c) => c.dataset.row === move.row && Number(c.dataset.col) === move.col
            );
            if (moveCell) moveCell.classList.add("available");
          });
        }
      }
    };

    resetBtn.addEventListener("click", setupGame);
    toggleHintsBtn.addEventListener("click", () => {
      showHints = !showHints;
      toggleHintsBtn.textContent = showHints ? "이동 표시 끄기" : "이동 표시 켜기";
      render();
    });

    setupGame();
  </script>
</body>
</html>
