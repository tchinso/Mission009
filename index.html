<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mission 009 보드게임</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --panel-2: #1f2937;
      --text: #e2e8f0;
      --accent: #38bdf8;
      --board: #334155;
      --cell: #1e293b;
      --cell-border: #475569;
      --truce: #14532d;
      --selected: #f59e0b;
      --move: #22c55e;
      --black: #0f172a;
      --white: #f8fafc;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Pretendard", "Noto Sans KR", sans-serif;
      background: radial-gradient(circle at top, #1e293b, #0b1120 60%);
      color: var(--text);
    }

    main {
      max-width: 1200px;
      margin: 0 auto;
      padding: 32px 20px 48px;
      display: grid;
      grid-template-columns: minmax(320px, 520px) 1fr;
      gap: 24px;
    }

    h1 {
      margin: 0 0 12px;
      font-size: 28px;
    }

    .panel {
      background: var(--panel);
      border: 1px solid #1f2937;
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.45);
    }

    .board-wrap {
      display: grid;
      gap: 12px;
    }

    .board {
      display: grid;
      grid-template-columns: 40px repeat(9, 1fr);
      grid-template-rows: 40px repeat(9, 1fr);
      border-radius: 16px;
      overflow: hidden;
      border: 2px solid #334155;
      background: var(--board);
    }

    .cell,
    .label {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      border: 1px solid var(--cell-border);
    }

    .cell {
      background: var(--cell);
      position: relative;
      min-height: 52px;
    }

    .label {
      background: #0b1120;
      font-weight: 700;
      color: #94a3b8;
    }

    .cell.truce {
      background: var(--truce);
    }

    .cell.selected {
      outline: 3px solid var(--selected);
      z-index: 2;
    }

    .cell.available::after {
      content: "";
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--move);
      position: absolute;
      bottom: 6px;
      right: 6px;
      box-shadow: 0 0 12px rgba(34, 197, 94, 0.7);
    }

    .piece {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 14px;
      border: 2px solid transparent;
      box-shadow: 0 0 12px rgba(15, 23, 42, 0.4);
    }

    .piece.black {
      background: #0f172a;
      color: #f8fafc;
      border-color: #94a3b8;
    }

    .piece.white {
      background: #f8fafc;
      color: #0f172a;
      border-color: #cbd5f5;
    }

    .mission {
      font-size: 13px;
      font-weight: 700;
      background: #0f172a;
      padding: 4px 6px;
      border-radius: 6px;
      color: #facc15;
    }

    .legend {
      display: grid;
      gap: 8px;
      font-size: 14px;
      line-height: 1.5;
    }

    .status {
      display: grid;
      gap: 8px;
      margin-top: 12px;
    }

    .turn {
      font-size: 16px;
      font-weight: 700;
      color: var(--accent);
    }

    .log {
      max-height: 220px;
      overflow-y: auto;
      background: #0b1120;
      border-radius: 12px;
      padding: 12px;
      font-size: 13px;
      line-height: 1.5;
    }

    .controls {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 12px;
    }

    button {
      border: none;
      background: var(--accent);
      color: #0b1120;
      font-weight: 700;
      padding: 10px 16px;
      border-radius: 10px;
      cursor: pointer;
    }

    button.secondary {
      background: #334155;
      color: #e2e8f0;
    }

    @media (max-width: 960px) {
      main {
        grid-template-columns: 1fr;
      }

      .board {
        width: min(100%, 520px);
        aspect-ratio: 1 / 1;
        grid-template-columns: 32px repeat(9, 1fr);
        grid-template-rows: 32px repeat(9, 1fr);
        justify-self: center;
      }

      .cell,
      .label {
        min-height: 0;
        aspect-ratio: 1 / 1;
      }
    }
  </style>
</head>
<body>
  <main>
    <section class="panel board-wrap">
      <h1>Mission 009 전략 보드게임</h1>
      <div id="board" class="board" aria-label="9x9 보드"></div>
      <div class="status">
        <div id="turn" class="turn"></div>
        <div id="message"></div>
        <div class="controls">
          <button id="reset">새 게임</button>
          <button id="toggleHints" class="secondary">이동 표시 끄기</button>
        </div>
      </div>
    </section>
    <aside class="panel">
      <h2>게임 규칙 요약</h2>
      <div class="legend">
        <div>• 검은색이 선공이며, 인접한 상하좌우·대각선 1칸 이동.</div>
        <div>• 검은색은 1열로 이동 불가, 흰색은 9열로 이동 불가.</div>
        <div>• 휴전지역(C5~G5)에 상대가 있으면 이동 불가.</div>
        <div>• 전투는 숫자 비교: 큰 숫자 승, 단 차이가 1이면 작은 숫자 승.</div>
        <div>• 1 vs 9은 1 승리, 2·3 vs 8은 작은 쪽 승리.</div>
        <div>• 같은 숫자는 이동한 쪽 승리.</div>
        <div>• 자신의 숫자와 일치하는 상대편 임무번호 칸 3곳 이상 도달 시 승리.</div>
      </div>
      <h3>전투 로그</h3>
      <div id="log" class="log"></div>
    </aside>
  </main>

  <script>
    const boardEl = document.getElementById("board");
    const turnEl = document.getElementById("turn");
    const messageEl = document.getElementById("message");
    const logEl = document.getElementById("log");
    const resetBtn = document.getElementById("reset");
    const toggleHintsBtn = document.getElementById("toggleHints");

    const ROWS = "ABCDEFGHI".split("");
    const COLS = [1, 2, 3, 4, 5, 6, 7, 8, 9];
    const STARTING_ORDER = [1, 3, 5, 7, 9, 8, 6, 4, 2];
    const TRUCE_ROWS = ["C", "D", "E", "F", "G"];
    const TRUCE_COL = 5;

    let state;
    let showHints = true;

    const createEmptyState = () => ({
      pieces: [],
      missions: { col1: {}, col9: {} },
      missionProgress: { black: [], white: [] },
      selected: null,
      currentPlayer: "black",
      gameOver: false,
    });

    const log = (text) => {
      const entry = document.createElement("div");
      entry.textContent = text;
      logEl.prepend(entry);
    };

    const coordKey = (row, col) => `${row}${col}`;

    const isTruce = (row, col) => TRUCE_COL === col && TRUCE_ROWS.includes(row);

    const generateMissionsForColumn = () => {
      const missions = {};
      const groups = [
        ["A", "B", "C"],
        ["D", "E", "F"],
        ["G", "H", "I"],
      ];

      const randomFrom = (arr) => arr[Math.floor(Math.random() * arr.length)];

      groups.forEach((group) => {
        const small = [1, 2, 3];
        const mid = [4, 5, 6];
        const large = [7, 8, 9];
        const values = [
          randomFrom(small),
          randomFrom(mid),
          randomFrom(large),
        ];
        const shuffled = values.sort(() => Math.random() - 0.5);
        group.forEach((row, idx) => {
          missions[row] = shuffled[idx];
        });
      });
      return missions;
    };

    const setupGame = () => {
      state = createEmptyState();
      state.missions.col1 = generateMissionsForColumn();
      state.missions.col9 = generateMissionsForColumn();
      state.pieces = [];
      ROWS.forEach((row, idx) => {
        const pieceNumber = STARTING_ORDER[idx];
        state.pieces.push({
          id: `B${pieceNumber}`,
          color: "black",
          number: pieceNumber,
          row,
          col: 2,
          alive: true,
        });
        state.pieces.push({
          id: `W${pieceNumber}`,
          color: "white",
          number: pieceNumber,
          row,
          col: 8,
          alive: true,
        });
      });
      state.selected = null;
      state.currentPlayer = "black";
      state.gameOver = false;
      logEl.innerHTML = "";
      messageEl.textContent = "";
      render();
      turnEl.textContent = "현재 턴: 검은색(플레이어)";
      log("새 게임 시작! 검은색이 먼저 움직입니다.");
    };

    const getPieceAt = (row, col) =>
      state.pieces.find((piece) => piece.alive && piece.row === row && piece.col === col);

    const inBounds = (rowIndex, colIndex) =>
      rowIndex >= 0 && rowIndex < 9 && colIndex >= 0 && colIndex < 9;

    const getLegalMoves = (piece) => {
      if (!piece || !piece.alive) return [];
      const moves = [];
      const rowIndex = ROWS.indexOf(piece.row);
      const colIndex = COLS.indexOf(piece.col);
      for (let dr = -1; dr <= 1; dr += 1) {
        for (let dc = -1; dc <= 1; dc += 1) {
          if (dr === 0 && dc === 0) continue;
          const nr = rowIndex + dr;
          const nc = colIndex + dc;
          if (!inBounds(nr, nc)) continue;
          const targetRow = ROWS[nr];
          const targetCol = COLS[nc];
          if (piece.color === "black" && targetCol === 1) continue;
          if (piece.color === "white" && targetCol === 9) continue;
          const occupant = getPieceAt(targetRow, targetCol);
          if (occupant && occupant.color === piece.color) continue;
          if (isTruce(targetRow, targetCol) && occupant && occupant.color !== piece.color) continue;
          moves.push({ row: targetRow, col: targetCol });
        }
      }
      return moves;
    };

    const compareBattle = (attacker, defender) => {
      if (attacker.number === defender.number) return "attacker";
      const diff = Math.abs(attacker.number - defender.number);
      if (diff === 1) return attacker.number < defender.number ? "attacker" : "defender";
      if (
        (attacker.number === 1 && defender.number === 9) ||
        (attacker.number === 9 && defender.number === 1)
      ) {
        return attacker.number === 1 ? "attacker" : "defender";
      }
      if (
        (attacker.number === 8 && [2, 3].includes(defender.number)) ||
        (defender.number === 8 && [2, 3].includes(attacker.number))
      ) {
        return [2, 3].includes(attacker.number) ? "attacker" : "defender";
      }
      return attacker.number > defender.number ? "attacker" : "defender";
    };

    const checkWin = (piece) => {
      if (!piece || !piece.alive) return false;
      if (piece.color === "black" && piece.col === 9) {
        if (state.missions.col9[piece.row] !== piece.number) return false;
        if (!state.missionProgress.black.includes(piece.row)) {
          state.missionProgress.black.push(piece.row);
        }
        return state.missionProgress.black.length >= 3;
      }
      if (piece.color === "white" && piece.col === 1) {
        if (state.missions.col1[piece.row] !== piece.number) return false;
        if (!state.missionProgress.white.includes(piece.row)) {
          state.missionProgress.white.push(piece.row);
        }
        return state.missionProgress.white.length >= 3;
      }
      return false;
    };

    const endGame = (winnerColor, reason) => {
      state.gameOver = true;
      const winnerName = winnerColor === "black" ? "검은색" : "흰색";
      messageEl.textContent = `${winnerName} 승리! ${reason}`;
      log(`${winnerName} 승리! ${reason}`);
      turnEl.textContent = "게임 종료";
    };

    const movePiece = (piece, destination) => {
      if (state.gameOver) return;
      const target = getPieceAt(destination.row, destination.col);
      let battleResult = null;
      if (target && !isTruce(destination.row, destination.col)) {
        battleResult = compareBattle(piece, target);
        if (battleResult === "attacker") {
          target.alive = false;
          log(`${piece.color === "black" ? "검" : "백"}${piece.number}가 ${target.color === "black" ? "검" : "백"}${target.number}를 격파!`);
        } else {
          piece.alive = false;
          log(`${piece.color === "black" ? "검" : "백"}${piece.number}가 ${target.color === "black" ? "검" : "백"}${target.number}에게 패배.`);
          return;
        }
      }
      piece.row = destination.row;
      piece.col = destination.col;
      if (checkWin(piece)) {
        endGame(piece.color, "임무번호 칸 3곳을 점령했습니다!");
      }
    };

    const aiEvaluateMove = (piece, move) => {
      const target = getPieceAt(move.row, move.col);
      let score = 0;
      if (target && !isTruce(move.row, move.col)) {
        const result = compareBattle(piece, target);
        score += result === "attacker" ? 80 : -80;
      }
      if (piece.color === "white" && move.col === 1) {
        if (state.missions.col1[move.row] === piece.number) {
          const projected = state.missionProgress.white.includes(move.row)
            ? state.missionProgress.white.length
            : state.missionProgress.white.length + 1;
          score += projected >= 3 ? 1000 : 200;
        }
      }
      const targetRow = Object.keys(state.missions.col1).find(
        (row) => state.missions.col1[row] === piece.number
      );
      if (targetRow) {
        const rowDistance = Math.abs(ROWS.indexOf(targetRow) - ROWS.indexOf(move.row));
        const colDistance = Math.abs(1 - move.col);
        score += 30 - rowDistance - colDistance;
      }

      const hypothetical = { ...piece, row: move.row, col: move.col };
      const blackThreats = state.pieces
        .filter((p) => p.alive && p.color === "black")
        .flatMap((p) =>
          getLegalMoves(p)
            .filter((m) => m.row === hypothetical.row && m.col === hypothetical.col)
            .map(() => p)
        );
      if (blackThreats.length > 0 && !isTruce(move.row, move.col)) {
        score -= 50;
      }
      return score;
    };

    const aiTurn = () => {
      if (state.gameOver) return;
      const candidates = [];
      state.pieces
        .filter((piece) => piece.alive && piece.color === "white")
        .forEach((piece) => {
          const moves = getLegalMoves(piece);
          moves.forEach((move) => {
            candidates.push({ piece, move, score: aiEvaluateMove(piece, move) });
          });
        });

      if (candidates.length === 0) {
        endGame("black", "흰색이 더 이상 움직일 수 없습니다.");
        return;
      }

      candidates.sort((a, b) => b.score - a.score);
      const best = candidates[0];
      movePiece(best.piece, best.move);
      if (!state.gameOver && best.piece.alive) {
        log(`흰색 ${best.piece.number}번 말 이동: ${best.move.row}${best.move.col}`);
      }
      state.currentPlayer = "black";
      state.selected = null;
      render();
      if (!state.gameOver) {
        turnEl.textContent = "현재 턴: 검은색(플레이어)";
      }
    };

    const handleCellClick = (row, col) => {
      if (state.gameOver) return;
      if (state.currentPlayer !== "black") return;
      const piece = getPieceAt(row, col);
      if (piece && piece.color === "black") {
        state.selected = piece;
        messageEl.textContent = `${piece.number}번 말을 선택했습니다.`;
        render();
        return;
      }
      if (!state.selected) return;
      const legal = getLegalMoves(state.selected);
      const isLegal = legal.some((m) => m.row === row && m.col === col);
      if (!isLegal) {
        messageEl.textContent = "이동할 수 없는 칸입니다.";
        return;
      }
      movePiece(state.selected, { row, col });
      if (!state.selected.alive) {
        state.selected = null;
      }
      if (!state.gameOver) {
        state.currentPlayer = "white";
        render();
        turnEl.textContent = "현재 턴: 흰색(AI)";
        setTimeout(aiTurn, 500);
      }
    };

    const buildBoard = () => {
      boardEl.innerHTML = "";
      const labelsTop = ["", ...COLS.map((c) => `${c}`)];
      labelsTop.forEach((label) => {
        const div = document.createElement("div");
        div.className = "label";
        div.textContent = label;
        boardEl.appendChild(div);
      });

      ROWS.forEach((row) => {
        const rowLabel = document.createElement("div");
        rowLabel.className = "label";
        rowLabel.textContent = row;
        boardEl.appendChild(rowLabel);
        COLS.forEach((col) => {
          const cell = document.createElement("div");
          cell.className = "cell";
          if (isTruce(row, col)) {
            cell.classList.add("truce");
          }
          cell.dataset.row = row;
          cell.dataset.col = col;
          cell.addEventListener("click", () => handleCellClick(row, col));
          boardEl.appendChild(cell);
        });
      });
    };

    const render = () => {
      if (!boardEl.children.length) buildBoard();
      const cells = boardEl.querySelectorAll(".cell");
      cells.forEach((cell) => {
        cell.innerHTML = "";
        cell.classList.remove("selected", "available");
      });

      cells.forEach((cell) => {
        const row = cell.dataset.row;
        const col = Number(cell.dataset.col);
        if (col === 1) {
          const mission = document.createElement("div");
          mission.className = "mission";
          mission.textContent = state.missions.col1[row];
          cell.appendChild(mission);
        }
        if (col === 9) {
          const mission = document.createElement("div");
          mission.className = "mission";
          mission.textContent = state.missions.col9[row];
          cell.appendChild(mission);
        }
      });

      state.pieces
        .filter((piece) => piece.alive)
        .forEach((piece) => {
          const cell = Array.from(cells).find(
            (c) => c.dataset.row === piece.row && Number(c.dataset.col) === piece.col
          );
          if (!cell) return;
          const pieceEl = document.createElement("div");
          pieceEl.className = `piece ${piece.color}`;
          pieceEl.textContent = piece.number;
          cell.appendChild(pieceEl);
        });

      if (state.selected) {
        const selectedCell = Array.from(cells).find(
          (c) => c.dataset.row === state.selected.row && Number(c.dataset.col) === state.selected.col
        );
        if (selectedCell) selectedCell.classList.add("selected");
        if (showHints) {
          const moves = getLegalMoves(state.selected);
          moves.forEach((move) => {
            const moveCell = Array.from(cells).find(
              (c) => c.dataset.row === move.row && Number(c.dataset.col) === move.col
            );
            if (moveCell) moveCell.classList.add("available");
          });
        }
      }
    };

    resetBtn.addEventListener("click", setupGame);
    toggleHintsBtn.addEventListener("click", () => {
      showHints = !showHints;
      toggleHintsBtn.textContent = showHints ? "이동 표시 끄기" : "이동 표시 켜기";
      render();
    });

    setupGame();
  </script>
</body>
</html>
